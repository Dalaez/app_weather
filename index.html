<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard Climático Global (v2.2.1)</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/choices.js@9.0.1/public/assets/styles/choices.min.css"/>
    <script src="https://cdn.jsdelivr.net/npm/choices.js@9.0.1/public/assets/scripts/choices.min.js"></script>

    <style>
        /* --- Fuentes y Fondo --- */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #d6e0ea 100%);
            color: #2c3e50;
            margin: 0;
            padding: 20px;
        }
        h1 {
            color: #1a2533;
            text-align: center;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.05);
        }
        h2 {
            color: #34495e;
            border-bottom: 2px solid #bdc3c7;
            padding-bottom: 5px;
            margin-top: 30px;
        }

        /* --- Contenedores "Glass" --- */
        #controls-container, #chart-container, .kpi-card {
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.18);
        }

        /* --- Controles --- */
        #controls-container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        #city-select-container { width: 400px; }
        .choices__inner { border-radius: 8px; }
        fieldset { border: none; padding: 0; margin: 0; }
        fieldset legend {
            font-weight: bold;
            padding: 0;
            margin-bottom: 8px;
            text-align: center;
            width: 100%;
        }

        /* --- Estilo para Selectores (Métrica y Rango) --- */
        .selector-group {
            display: flex;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 10px rgba(0,0,0,0.05);
        }
        .selector-group input {
            opacity: 0;
            position: fixed;
            width: 0;
        }
        .selector-group label,
        .time-btn {
            background-color: #fff;
            border: none;
            padding: 8px 14px;
            cursor: pointer;
            color: #555;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s ease;
            border-right: 1px solid #eee;
        }
        .selector-group label:last-of-type,
        .time-btn:last-of-type {
            border-right: none;
        }
        .selector-group input:not(:checked) + label:hover,
        .time-btn:not(.active):hover {
            background-color: #f4f4f4;
            color: #000;
        }
        .selector-group input:checked + label,
        .time-btn.active {
            color: white;
            background-image: linear-gradient(to right, #4363d8, #6a82e0);
            box-shadow: 0 2px 8px rgba(67, 99, 216, 0.3);
            transform: scale(1.05);
        }

        /* --- Estilo Tarjetas KPI --- */
        #kpi-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); /* Más ancho */
            gap: 20px;
            margin-bottom: 20px;
        }
        .kpi-card {
            padding: 20px;
            border-left: 6px solid;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .kpi-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 32px 0 rgba(31, 38, 135, 0.15);
        }
        .kpi-card h3 { 
            margin: 0 0 12px 0; 
            color: #2c3e50; 
            font-size: 1.25em;
        }
        .kpi-card p { margin: 5px 0; font-size: 1em; }
        .kpi-card .kpi-temp {
            font-weight: 700;
            font-size: 1.8em;
            color: #e74c3c;
            margin-bottom: 12px;
        }
        .kpi-hist {
            font-size: 0.9em;
            color: #555;
            display: flex;
            flex-direction: column; /* Apilamos min y max */
            gap: 5px; /* Espacio entre min y max */
            border-top: 1px solid #eee;
            padding-top: 10px;
            margin-top: 10px;
        }
        .kpi-hist-item {
            display: flex;
            justify-content: space-between;
        }
        .kpi-hist-item .date { /* Estilo para la fecha */
            color: #7f8c8d;
            font-size: 0.9em;
            padding-left: 5px;
        }
        
        /* --- [CAMBIO] Contenedor del Gráfico --- */
        #chart-container {
            width: 100%;
            padding: 20px;
            box-sizing: border-box;
            /* [CAMBIO] Devolvemos la altura al gráfico */
            min-height: 500px; 
            position: relative;
        }
        /* Hacemos que el canvas ocupe todo el contenedor */
        #myChart {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding: 20px;
            box-sizing: border-box;
        }
    </style>
</head>
<body>

    <h1>Dashboard Climático Global</h1>

    <div id="controls-container">
        <div id="city-select-container">
            <label for="city-select" style="font-weight: bold; margin-bottom: 5px; display: block;">Selecciona hasta 5 ciudades:</label>
            <select id="city-select" multiple></select>
        </div>
        
        <div id="metric-select">
            <fieldset>
                <legend>Métrica</legend>
                <div class="selector-group">
                    <input type="radio" name="metric" value="temp" id="m-temp" checked>
                    <label for="m-temp">Temperatura</label>
                    
                    <input type="radio" name="metric" value="humidity" id="m-humidity">
                    <label for="m-humidity">Humedad</label>
                    
                    <input type="radio" name="metric" value="wind" id="m-wind">
                    <label for="m-wind">Viento</label>
                </div>
            </fieldset>
        </div>

        <div id="time-range-select">
            <fieldset>
                <legend>Rango</legend>
                <div class="selector-group">
                    <button class="time-btn" data-range="7">1S</button>
                    <button class="time-btn" data-range="30">1M</button>
                    <button class="time-btn" data-range="90">3M</button>
                    <button class="time-btn" data-range="365">1A</button>
                    <button class="time-btn" data-range="1825">5A</button>
                    <button class="time-btn active" data-range="all">Todo</button>
                </div>
            </fieldset>
        </div>
    </div>

    <h2>Datos más recientes</h2>
    <div id="kpi-container"></div>

    <h2>Evolución Histórica</h2>
    <div id="chart-container">
        <canvas id="myChart"></canvas>
    </div>

    <script>
        // --- Configuración Global (Sin cambios) ---
        const CITIES_LIST_URL = 'ciudades.txt';
        const DATA_FOLDER_URL = 'datos/';
        const citySelectorElement = document.getElementById('city-select');
        const kpiContainer = document.getElementById('kpi-container');
        const metricRadios = document.querySelectorAll('input[name="metric"]');
        const timeRangeButtons = document.querySelectorAll('.time-btn');
        const ctx = document.getElementById('myChart').getContext('2d');
        let myChart;
        let choicesInstance;
        let allDataCache = {};
        let currentTimeRange = 'all';
        const COLOR_PALETTE = ['#e6194B', '#3cb44b', '#ffe119', '#4363d8', '#f58231', '#911eb4'];
        
        // --- [CAMBIO] 1. Calcular Stats al Cargar CSV (Ahora guarda fechas) ---
        function calculateStats(records) {
            // [CAMBIO] Inicializamos los stats con objetos para guardar valor y fecha
            const stats = {
                min_temp: { value: Infinity, date: null }, max_temp: { value: -Infinity, date: null },
                min_humidity: { value: Infinity, date: null }, max_humidity: { value: -Infinity, date: null },
                min_wind: { value: Infinity, date: null }, max_wind: { value: -Infinity, date: null },
            };
            
            records.forEach(row => {
                row.fecha_hora = new Date(row.fecha_hora); 
                
                // Comparamos y guardamos valor + fecha
                if (row.temperatura_c < stats.min_temp.value) {
                    stats.min_temp = { value: row.temperatura_c, date: row.fecha_hora };
                }
                if (row.temperatura_c > stats.max_temp.value) {
                    stats.max_temp = { value: row.temperatura_c, date: row.fecha_hora };
                }
                if (row.humedad_porc < stats.min_humidity.value) {
                    stats.min_humidity = { value: row.humedad_porc, date: row.fecha_hora };
                }
                if (row.humedad_porc > stats.max_humidity.value) {
                    stats.max_humidity = { value: row.humedad_porc, date: row.fecha_hora };
                }
                if (row.viento_kmh < stats.min_wind.value) {
                    stats.min_wind = { value: row.viento_kmh, date: row.fecha_hora };
                }
                if (row.viento_kmh > stats.max_wind.value) {
                    stats.max_wind = { value: row.viento_kmh, date: row.fecha_hora };
                }
            });
            return stats;
        }

        // --- 2. Función de Carga de CSV (Sin cambios) ---
        function loadCSV(ciudad) {
            if (allDataCache[ciudad]) {
                return Promise.resolve(allDataCache[ciudad]);
            }
            
            const nombreFichero = ciudad.replace(/ /g, '_') + '.csv';
            const csvUrl = DATA_FOLDER_URL + nombreFichero;

            return new Promise((resolve, reject) => {
                Papa.parse(csvUrl, {
                    download: true,
                    header: true,
                    dynamicTyping: true,
                    skipEmptyLines: true,
                    complete: (results) => {
                        const records = results.data;
                        if (records.length === 0) {
                            allDataCache[ciudad] = { records: [], stats: {} };
                            resolve(allDataCache[ciudad]);
                            return;
                        }
                        
                        const stats = calculateStats(records);
                        allDataCache[ciudad] = { records, stats }; 
                        console.log(`Datos y stats calculados para ${ciudad}`);
                        resolve(allDataCache[ciudad]);
                    },
                    error: (err) => {
                        console.error(`Error cargando ${csvUrl}:`, err);
                        reject(err);
                    }
                });
            });
        }

        // --- 3. Función de Carga Múltiple (Sin cambios) ---
        async function loadDataForCities(ciudades) {
            const promises = ciudades.map(ciudad => loadCSV(ciudad));
            try {
                const datasets = await Promise.all(promises);
                const cityDataMap = {};
                ciudades.forEach((ciudad, index) => {
                    cityDataMap[ciudad] = datasets[index];
                });
                return cityDataMap;
            } catch (error) {
                console.error("Fallo al cargar uno o más datasets:", error);
                kpiContainer.innerHTML = "<p>Error al cargar los datos. Revisa la consola.</p>";
                return null;
            }
        }

        // --- 4. Función para Actualizar el Dashboard (Sin cambios) ---
        async function updateDashboard() {
            const selectedCities = choicesInstance.getValue(true);
            const selectedMetric = document.querySelector('input[name="metric"]:checked').value;

            if (selectedCities.length === 0) {
                kpiContainer.innerHTML = "<p>Selecciona una o más ciudades para empezar.</p>";
                if (myChart) myChart.destroy();
                return;
            }
            
            const cityDataMap = await loadDataForCities(selectedCities);
            if (!cityDataMap) return;

            updateKPIs(cityDataMap, selectedMetric);
            updateChart(cityDataMap, selectedMetric);
        }

        // --- [CAMBIO] 5. Función para Actualizar las Tarjetas de KPI (con fechas) ---
        function updateKPIs(cityDataMap, selectedMetric) {
            kpiContainer.innerHTML = '';
            
            // Función helper para formatear fechas
            const formatDate = (date) => {
                if (!date) return '';
                return date.toLocaleString('es-ES', { day: 'numeric', month: 'short' });
            };

            Object.keys(cityDataMap).forEach((ciudad, index) => {
                const data = cityDataMap[ciudad];
                if (!data || data.records.length === 0) return;

                const latestData = data.records[data.records.length - 1];
                const stats = data.stats;
                const cardColor = COLOR_PALETTE[index % COLOR_PALETTE.length];

                let minHist, maxHist, minDate, maxDate, unit;
                switch(selectedMetric) {
                    case 'humidity':
                        minHist = (stats.min_humidity.value === Infinity) ? 'N/A' : stats.min_humidity.value.toFixed(0);
                        maxHist = (stats.max_humidity.value === -Infinity) ? 'N/A' : stats.max_humidity.value.toFixed(0);
                        minDate = formatDate(stats.min_humidity.date);
                        maxDate = formatDate(stats.max_humidity.date);
                        unit = '%';
                        break;
                    case 'wind':
                        minHist = (stats.min_wind.value === Infinity) ? 'N/A' : stats.min_wind.value.toFixed(1);
                        maxHist = (stats.max_wind.value === -Infinity) ? 'N/A' : stats.max_wind.value.toFixed(1);
                        minDate = formatDate(stats.min_wind.date);
                        maxDate = formatDate(stats.max_wind.date);
                        unit = ' km/h';
                        break;
                    default: // 'temp'
                        minHist = (stats.min_temp.value === Infinity) ? 'N/A' : stats.min_temp.value.toFixed(1);
                        maxHist = (stats.max_temp.value === -Infinity) ? 'N/A' : stats.max_temp.value.toFixed(1);
                        minDate = formatDate(stats.min_temp.date);
                        maxDate = formatDate(stats.max_temp.date);
                        unit = '°C';
                }

                const cardHTML = `
                    <div class="kpi-card" style="border-left-color: ${cardColor};">
                        <h3>${ciudad}</h3>
                        <p class="kpi-temp">${latestData.temperatura_c.toFixed(1)} °C</p>
                        <p>Sensación: <strong>${latestData.sensacion_c.toFixed(1)} °C</strong></p>
                        <p>Humedad: <strong>${latestData.humedad_porc} %</strong></p>
                        <p>Viento: <strong>${latestData.viento_kmh} km/h</strong></p>
                        
                        <div class="kpi-hist">
                            <div class="kpi-hist-item">
                                <span>Min Hist (${unit}): <strong>${minHist}</strong></span>
                                <span class="date">${minDate}</span>
                            </div>
                            <div class="kpi-hist-item">
                                <span>Max Hist (${unit}): <strong>${maxHist}</strong></span>
                                <span class="date">${maxDate}</span>
                            </div>
                        </div>
                    </div>
                `;
                kpiContainer.innerHTML += cardHTML;
            });
        }
        
        // --- 6. Función para Actualizar el Gráfico Histórico (Sin cambios) ---
        function updateChart(cityDataMap, metric) {
            if (myChart) {
                myChart.destroy();
            }
            
            const metricMap = {
                'temp': { key: 'temperatura_c', label: 'Temperatura (°C)' },
                'humidity': { key: 'humedad_porc', label: 'Humedad (%)' },
                'wind': { key: 'viento_kmh', label: 'Viento (km/h)' }
            };
            const currentMetric = metricMap[metric];
            
            const now = new Date();
            let startDate = new Date(0); 
            
            if (currentTimeRange !== 'all') {
                startDate = new Date();
                startDate.setDate(now.getDate() - parseInt(currentTimeRange));
            }

            const datasets = [];
            let allLabels = new Set();
            let cityDataSets = {};
            
            Object.keys(cityDataMap).forEach((ciudad) => {
                const data = cityDataMap[ciudad];
                if (!data || data.records.length === 0) return;

                const filteredData = data.records.filter(row => row.fecha_hora >= startDate);
                cityDataSets[ciudad] = {};

                filteredData.forEach(row => {
                    const label = row.fecha_hora.toLocaleString('es-ES', { 
                        day: 'numeric', month: 'short', hour: '2-digit', minute: '2-digit' 
                    });
                    allLabels.add(label);
                    cityDataSets[ciudad][label] = row[currentMetric.key];
                });
            });

            // Ordenamos las etiquetas
            const sortedLabels = Array.from(allLabels).sort((a, b) => {
                // Pequeño truco para parsear fechas "25 oct, 14:44"
                const parseDate = (str) => {
                    const parts = str.match(/(\d+)\s(\w+)\.?,\s(\d+):(\d+)/);
                    if (!parts) return new Date(0);
                    const months = ['ene', 'feb', 'mar', 'abr', 'may', 'jun', 'jul', 'ago', 'sep', 'oct', 'nov', 'dic'];
                    const monthIndex = months.indexOf(parts[2].toLowerCase());
                    // Asumimos el año actual, para la ordenación es suficiente
                    return new Date(new Date().getFullYear(), monthIndex, parts[1], parts[3], parts[4]);
                };
                return parseDate(a) - parseDate(b);
            });


            Object.keys(cityDataSets).forEach((ciudad, index) => {
                const chartData = sortedLabels.map(label => {
                    return cityDataSets[ciudad][label] || null; 
                });

                datasets.push({
                    label: `${ciudad}`,
                    data: chartData,
                    borderColor: COLOR_PALETTE[index % COLOR_PALETTE.length],
                    backgroundColor: 'transparent',
                    tension: 0.1,
                    spanGaps: true,
                    borderWidth: 2, // [CAMBIO] Líneas un poco más gruesas
                    pointRadius: 1.5 // [CAMBIO] Puntos más pequeños
                });
            });

            myChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: sortedLabels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false, // ¡Clave para que min-height funcione!
                    plugins: {
                        title: {
                            display: true,
                            text: `Evolución Histórica de ${currentMetric.label}`,
                            font: { size: 18 }
                        },
                        legend: {
                            position: 'top',
                        }
                    },
                    scales: {
                        y: {
                            title: {
                                display: true,
                                text: currentMetric.label
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Fecha'
                            }
                        }
                    },
                    interaction: {
                        mode: 'index',
                        intersect: false
                    }
                }
            });
        }

        // --- 7. Función de Inicialización (Sin cambios en la lógica) ---
        async function init() {
            choicesInstance = new Choices(citySelectorElement, {
                removeItemButton: true,
                maxItemCount: 5,
                placeholder: true,
                placeholderValue: 'Escribe para buscar...',
                searchResultLimit: 50,
            });

            try {
                const response = await fetch(CITIES_LIST_URL);
                const text = await response.text();
                const ciudades = text.split('\n')
                                     .map(city => city.trim())
                                     .filter(city => city.length > 0)
                                     .map(city => ({ value: city, label: city }));
                
                choicesInstance.setChoices(ciudades, 'value', 'label', false);
                choicesInstance.setChoiceByValue(['Madrid', 'León', 'Barcelona']); // Añadida BCN para el ejemplo
                updateDashboard();

            } catch (error) {
                console.error("Error al cargar la lista de ciudades:", error);
                alert("No se pudo cargar la lista de ciudades.");
            }
            
            citySelectorElement.addEventListener('change', updateDashboard);
            
            metricRadios.forEach(radio => radio.addEventListener('change', updateDashboard));

            timeRangeButtons.forEach(button => {
                button.addEventListener('click', () => {
                    currentTimeRange = button.dataset.range;
                    timeRangeButtons.forEach(btn => btn.classList.remove('active'));
                    button.classList.add('active');
                    updateDashboard();
                });
            });
        }
        
        // --- INICIO DE LA APLICACIÓN ---
        init();
    </script>
</body>
</html>