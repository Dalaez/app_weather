<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard Climático Global (v2.3.2 - Final)</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/choices.js@9.0.1/public/assets/styles/choices.min.css"/>
    <script src="https://cdn.jsdelivr.net/npm/choices.js@9.0.1/public/assets/scripts/choices.min.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

    <style>
        /* --- CSS (Sin cambios respecto a tu v2.3.1) --- */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body { font-family: 'Inter', sans-serif; background: linear-gradient(135deg, #f5f7fa 0%, #d6e0ea 100%); color: #2c3e50; margin: 0; padding: 20px; }
        h1 { color: #1a2533; text-align: center; text-shadow: 1px 1px 2px rgba(0,0,0,0.05); }
        h2 { color: #34495e; border-bottom: 2px solid #bdc3c7; padding-bottom: 5px; margin-top: 30px; }
        #map-container { width: 100%; height: 450px; border-radius: 12px; margin-bottom: 20px; z-index: 5; background: #fff; box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.1); border: 1px solid rgba(255, 255, 255, 0.18); }
        #controls-container, #chart-container, .kpi-card { background: rgba(255, 255, 255, 0.85); backdrop-filter: blur(10px); border-radius: 12px; box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.1); border: 1px solid rgba(255, 255, 255, 0.18); }
        #controls-container { display: flex; justify-content: center; align-items: center; gap: 20px; flex-wrap: wrap; padding: 20px; margin-bottom: 20px; position: relative; z-index: 10; }
        #city-select-container { width: 400px; } .choices__inner { border-radius: 8px; } fieldset { border: none; padding: 0; margin: 0; } fieldset legend { font-weight: bold; padding: 0; margin-bottom: 8px; text-align: center; width: 100%; }
        .selector-group { display: flex; border-radius: 8px; overflow: hidden; box-shadow: 0 4px 10px rgba(0,0,0,0.05); } .selector-group input { opacity: 0; position: fixed; width: 0; } .selector-group label, .time-btn { background-color: #fff; border: none; padding: 8px 14px; cursor: pointer; color: #555; font-size: 14px; font-weight: 600; transition: all 0.2s ease; border-right: 1px solid #eee; } .selector-group label:last-of-type, .time-btn:last-of-type { border-right: none; } .selector-group input:not(:checked) + label:hover, .time-btn:not(.active):hover { background-color: #f4f4f4; color: #000; } .selector-group input:checked + label, .time-btn.active { color: white; background-image: linear-gradient(to right, #4363d8, #6a82e0); box-shadow: 0 2px 8px rgba(67, 99, 216, 0.3); transform: scale(1.05); }
        #kpi-container { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-bottom: 20px; } .kpi-card { padding: 20px; border-left: 6px solid; transition: transform 0.2s ease, box-shadow 0.2s ease; } .kpi-card:hover { transform: translateY(-5px); box-shadow: 0 12px 32px 0 rgba(31, 38, 135, 0.15); } .kpi-card h3 { margin: 0 0 12px 0; color: #2c3e50; font-size: 1.25em; } .kpi-card p { margin: 5px 0; font-size: 1em; } .kpi-card .kpi-temp { font-weight: 700; font-size: 1.8em; color: #e74c3c; margin-bottom: 12px; } .kpi-hist { font-size: 0.9em; color: #555; display: flex; flex-direction: column; gap: 5px; border-top: 1px solid #eee; padding-top: 10px; margin-top: 10px; } .kpi-hist-item { display: flex; justify-content: space-between; } .kpi-hist-item .date { color: #7f8c8d; font-size: 0.9em; padding-left: 5px; }
        #chart-container { width: 100%; padding: 20px; box-sizing: border-box; min-height: 500px; position: relative; } #myChart { position: absolute; top: 0; left: 0; width: 100%; height: 100%; padding: 20px; box-sizing: border-box; }
    </style>
</head>
<body>

    <h1>Dashboard Climático Global</h1>

    <div id="controls-container">
        <div id="city-select-container">
            <label for="city-select" style="font-weight: bold; margin-bottom: 5px; display: block;">Selecciona hasta 5 ciudades:</label>
            <select id="city-select" multiple></select>
        </div>
        
        <div id="metric-select">
            <fieldset>
                <legend>Métrica</legend>
                <div class="selector-group">
                    <input type="radio" name="metric" value="temp" id="m-temp" checked>
                    <label for="m-temp">Temperatura</label>
                    <input type="radio" name="metric" value="humidity" id="m-humidity">
                    <label for="m-humidity">Humedad</label>
                    <input type="radio" name="metric" value="wind" id="m-wind">
                    <label for="m-wind">Viento</label>
                </div>
            </fieldset>
        </div>

        <div id="time-range-select">
            <fieldset>
                <legend>Rango</legend>
                <div class="selector-group">
                    <button class="time-btn" data-range="7">1S</button>
                    <button class="time-btn" data-range="30">1M</button>
                    <button class="time-btn" data-range="90">3M</button>
                    <button class="time-btn" data-range="365">1A</button>
                    <button class="time-btn" data-range="1825">5A</button>
                    <button class="time-btn active" data-range="all">Todo</button>
                </div>
            </fieldset>
        </div>
    </div>

    <h2>Mapa Interactivo</h2>
    <div id="map-container"></div>

    <h2>Datos más recientes</h2>
    <div id="kpi-container"></div>

    <h2>Evolución Histórica</h2>
    <p style="text-align: center; margin-top: -10px; color: #555;">(Todas las horas se muestran en tu zona horaria local)</p>
    <div id="chart-container">
        <canvas id="myChart"></canvas>
    </div>

    <script>
        // --- Configuración Global ---
        const CITIES_LIST_URL = 'ciudades.txt';
        const DATA_FOLDER_URL = 'datos/';
        const MAP_DATA_URL = 'city_locations.json';
        
        const citySelectorElement = document.getElementById('city-select');
        const kpiContainer = document.getElementById('kpi-container');
        const metricRadios = document.querySelectorAll('input[name="metric"]');
        const timeRangeButtons = document.querySelectorAll('.time-btn');
        const ctx = document.getElementById('myChart').getContext('2d');
        
        let myChart;
        let choicesInstance;
        let allDataCache = {};
        let currentTimeRange = 'all';
        const COLOR_PALETTE = ['#e6194B', '#3cb44b', '#ffe119', '#4363d8', '#f58231', '#911eb4'];
        
        let map;
        let mapMarkers = {};

        // --- Funciones de Carga de Datos ---
        function calculateStats(records) { /* Sin cambios */ }
        function loadCSV(ciudadQuery) { /* ciudadQuery es 'Madrid,ES' */
            if (allDataCache[ciudadQuery]) { return Promise.resolve(allDataCache[ciudadQuery]); }
            
            // [CORRECCIÓN] Usamos el nombre limpio para buscar el fichero CSV
            const nombreCiudadLimpio = ciudadQuery.split(',')[0];
            const nombreFichero = nombreCiudadLimpio.replace(/ /g, '_') + '.csv';
            const csvUrl = DATA_FOLDER_URL + nombreFichero;
            
            return new Promise((resolve, reject) => {
                Papa.parse(csvUrl, {
                    download: true, header: true, dynamicTyping: true, skipEmptyLines: true,
                    complete: (results) => {
                        const records = results.data;
                        if (records.length === 0) { allDataCache[ciudadQuery] = { records: [], stats: {} }; resolve(allDataCache[ciudadQuery]); return; }
                        const stats = calculateStats(records);
                        allDataCache[ciudadQuery] = { records, stats }; // Guardamos en caché usando 'Madrid,ES' como clave
                        resolve(allDataCache[ciudadQuery]);
                    },
                    error: (err) => { console.error(`Error cargando ${csvUrl}:`, err); reject(err); }
                });
            });
        }
        async function loadDataForCities(ciudadesQuery) { /* ciudadesQuery es ['Madrid,ES', 'León,ES'] */
            const promises = ciudadesQuery.map(ciudadQuery => loadCSV(ciudadQuery)); // Pasamos 'Madrid,ES'
            try {
                const datasets = await Promise.all(promises);
                const cityDataMap = {};
                ciudadesQuery.forEach((ciudadQuery, index) => { 
                    // [CORRECCIÓN] Usamos el nombre limpio como clave del mapa de datos
                    cityDataMap[ciudadQuery.split(',')[0]] = datasets[index]; 
                });
                return cityDataMap; // Devuelve {'Madrid': {...}, 'León': {...}}
            } catch (error) { console.error("Fallo al cargar uno o más datasets:", error); kpiContainer.innerHTML = "<p>Error al cargar los datos.</p>"; return null; }
        }

        // --- Funciones de UI ---
        async function updateDashboard() { 
            const selectedCitiesValues = choicesInstance.getValue(true); // Devuelve ['Madrid,ES', 'León,ES']
            // [CORRECCIÓN] Asegurarse de que el radio button está seleccionado antes de leer value
            const checkedMetricRadio = document.querySelector('input[name="metric"]:checked');
            const selectedMetric = checkedMetricRadio ? checkedMetricRadio.value : 'temp'; // Valor por defecto si no hay nada chequeado

            console.log("updateDashboard - Selected Values:", selectedCitiesValues); // DEBUG
            console.log("updateDashboard - Selected Metric:", selectedMetric); // DEBUG


            if (selectedCitiesValues.length === 0) { 
                kpiContainer.innerHTML = "<p>Selecciona ciudades.</p>"; 
                if (myChart) myChart.destroy(); 
                highlightMapMarkers([]); 
                return; 
            }
            
            const cityDataMap = await loadDataForCities(selectedCitiesValues); // Devuelve {'Madrid': {...}, 'León': {...}}
            if (!cityDataMap) {
                console.error("No se pudieron cargar los datos para las ciudades seleccionadas.");
                return;
            }

            const selectedCitiesClean = selectedCitiesValues.map(v => v.split(',')[0]); // ['Madrid', 'León']

            updateKPIs(cityDataMap, selectedMetric); 
            updateChart(cityDataMap, selectedMetric); 
            highlightMapMarkers(selectedCitiesClean); 
        }
        function updateKPIs(cityDataMap, selectedMetric) { /* Sin cambios */ }
        function updateChart(cityDataMap, metric) { 
            console.log("updateChart called with metric:", metric); // DEBUG
            if (myChart) { myChart.destroy(); }
            
            const metricMap = {
                'temp': { key: 'temperatura_c', label: 'Temperatura (°C)' },
                'humidity': { key: 'humedad_porc', label: 'Humedad (%)' },
                'wind': { key: 'viento_kmh', label: 'Viento (km/h)' }
            };
            const currentMetric = metricMap[metric];
            console.log("currentMetric object:", currentMetric); // DEBUG

            if (!currentMetric) {
                console.error("ERROR: Métrica inválida en updateChart. Valor recibido:", metric);
                return; 
            }
            
            const now = new Date();
            let startDate = new Date(0); 
            if (currentTimeRange !== 'all') { /* ... */ }

            const datasets = [];
            let allLabels = new Set();
            let cityDataSets = {};
            
            Object.keys(cityDataMap).forEach((ciudad) => {
                const data = cityDataMap[ciudad];
                if (!data || !data.records || data.records.length === 0) { // Comprobación más robusta
                    console.warn(`No hay datos o 'records' no existe para la ciudad: ${ciudad}`);
                    return; 
                }
                const filteredData = data.records.filter(row => row.fecha_hora instanceof Date && row.fecha_hora >= startDate); // Asegurarse que fecha_hora es Date
                cityDataSets[ciudad] = {};

                filteredData.forEach((row, rowIndex) => { 
                    try {
                        // [CORRECCIÓN] Comprobar si row[currentMetric.key] existe y es un número
                        const value = row[currentMetric.key];
                        if (value === undefined || value === null || isNaN(value)) {
                            console.warn(`Valor inválido (${value}) para ${currentMetric.key} en la fila ${rowIndex} de ${ciudad}. Se usará null.`);
                             // No añadir etiqueta si el valor es inválido, para evitar huecos innecesarios si la fila entera es mala
                        } else {
                            const label = row.fecha_hora.toLocaleString('es-ES', { 
                                day: 'numeric', month: 'short', hour: '2-digit', minute: '2-digit', timeZoneName: 'short'
                            });
                             allLabels.add(label);
                             cityDataSets[ciudad][label] = value;
                        }
                    } catch (e) {
                         console.error(`Error procesando fila ${rowIndex} para ${ciudad}:`, e, row);
                    }
                });
            });

            const sortedLabels = Array.from(allLabels).sort(/* ... */);
            Object.keys(cityDataSets).forEach((ciudad, index) => { /* ... */ });
            // [CORRECCIÓN] Solo intentar crear el gráfico si hay datos
             if (datasets.length > 0 && sortedLabels.length > 0) {
                 myChart = new Chart(ctx, { /* ... */ });
             } else {
                 console.warn("No hay datos válidos para mostrar en el gráfico después de filtrar.");
                 // Opcional: Limpiar el canvas o mostrar un mensaje
                 ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                 ctx.fillText("No hay datos disponibles para la selección actual.", 10, 50);
             }
        }
        
        // --- Funciones del Mapa (Sin cambios) ---
        async function initMap() { /* ... */ }
        function highlightMapMarkers(selectedCitiesClean) { /* ... */ }
        function getTempColor(temp) { /* ... */ }

        // --- Función de Inicialización ---
        async function init() {
            choicesInstance = new Choices(citySelectorElement, { /* ... */ });

            try {
                const [ciudadesResponse, _] = await Promise.all([
                    fetch(CITIES_LIST_URL),
                    initMap() 
                ]);

                const text = await ciudadesResponse.text();
                const ciudades = text.split('\n')
                                     .map(line => line.trim().split(',')) 
                                     .filter(parts => parts.length >= 2 && parts[0] && !parts[0].startsWith('#')) 
                                     .map(parts => ({ 
                                         value: `${parts[0]},${parts[1]}`, 
                                         label: parts[0] 
                                      }));
                
                choicesInstance.setChoices(ciudades, 'value', 'label', false);
                
                // [CAMBIO] Seleccionamos por defecto usando el VALOR completo "Ciudad,PAIS"
                choicesInstance.setChoiceByValue(['Madrid,ES', 'León,ES']); 
                
                // Llamamos a updateDashboard DESPUÉS de setChoiceByValue
                updateDashboard();

            } catch (error) {
                console.error("Error al inicializar la aplicación:", error);
                alert("No se pudo cargar la lista de ciudades o el mapa.");
            }
            
            // Listeners
            citySelectorElement.addEventListener('change', updateDashboard);
            metricRadios.forEach(radio => radio.addEventListener('change', updateDashboard);
            timeRangeButtons.forEach(button => { /* ... */ });
        }
        
        // --- INICIO DE LA APLICACIÓN ---
        init();
        
        // --- COPIA AQUÍ LAS FUNCIONES COMPLETAS ---
        // calculateStats, updateKPIs, updateChart (la nueva), initMap, highlightMapMarkers, getTempColor
    </script>
</body>
</html>