<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard Climático Global (v2.1)</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/choices.js@9.0.1/public/assets/styles/choices.min.css"/>
    <script src="https://cdn.jsdelivr.net/npm/choices.js@9.0.1/public/assets/scripts/choices.min.js"></script>

    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #f0f2f5;
            color: #333;
            margin: 0;
            padding: 20px;
        }
        h1 {
            color: #2c3e50;
            text-align: center;
        }
        
        #controls-container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
            padding: 20px;
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
            margin-bottom: 20px;
        }
        
        .choices__inner { background-color: #fff; }
        #city-select-container { width: 400px; }

        fieldset {
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
            display: flex;
            gap: 15px;
        }
        fieldset legend { font-weight: bold; padding: 0 5px; }

        /* [NUEVO] Estilo para los botones de zoom */
        #time-range-select button {
            background-color: #fff;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 5px 10px;
            cursor: pointer;
            font-size: 14px;
        }
        #time-range-select button.active {
            background-color: #4363d8;
            color: white;
            border-color: #4363d8;
        }

        #kpi-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); /* Un poco más ancho */
            gap: 20px;
            margin-bottom: 20px;
        }
        .kpi-card {
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
            padding: 15px;
            border-left: 5px solid #1abc9c;
        }
        .kpi-card h3 { margin: 0 0 10px 0; color: #2c3e50; }
        .kpi-card p { margin: 5px 0; font-size: 1em; } /* Tamaño normalizado */
        .kpi-card .kpi-temp {
            font-weight: bold;
            font-size: 1.5em;
            color: #e74c3c;
            margin-bottom: 10px;
        }
        /* [NUEVO] Estilo para los min/max históricos */
        .kpi-hist {
            font-size: 0.9em;
            color: #555;
            display: flex;
            justify-content: space-between;
            border-top: 1px solid #eee;
            padding-top: 8px;
            margin-top: 8px;
        }
        
        #chart-container {
            width: 100%;
            padding: 20px;
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
            box-sizing: border-box;
        }
    </style>
</head>
<body>

    <h1>Dashboard Climático Global (v2.1)</h1>

    <div id="controls-container">
        <div id="city-select-container">
            <label for="city-select" style="font-weight: bold; margin-bottom: 5px; display: block;">Selecciona hasta 5 ciudades:</label>
            <select id="city-select" multiple></select>
        </div>
        
        <div id="metric-select">
            <fieldset>
                <legend>Métrica</legend>
                <label><input type="radio" name="metric" value="temp" checked> Temp.</label>
                <label><input type="radio" name="metric" value="humidity"> Humedad</label>
                <label><input type="radio" name="metric" value="wind"> Viento</label>
            </fieldset>
        </div>

        <div id="time-range-select">
            <fieldset>
                <legend>Rango</legend>
                <button class="time-btn" data-range="7">1S</button>
                <button class="time-btn" data-range="30">1M</button>
                <button class="time-btn" data-range="90">3M</button>
                <button class="time-btn" data-range="365">1A</button>
                <button class="time-btn" data-range="1825">5A</button>
                <button class="time-btn active" data-range="all">Todo</button>
            </fieldset>
        </div>
    </div>

    <h2>Datos más recientes</h2>
    <div id="kpi-container"></div>

    <h2>Evolución Histórica</h2>
    <div id="chart-container">
        <canvas id="myChart"></canvas>
    </div>

    <script>
        // --- Configuración Global ---
        const CITIES_LIST_URL = 'ciudades.txt';
        const DATA_FOLDER_URL = 'datos/';
        
        const citySelectorElement = document.getElementById('city-select');
        const kpiContainer = document.getElementById('kpi-container');
        const metricRadios = document.querySelectorAll('input[name="metric"]');
        const timeRangeButtons = document.querySelectorAll('.time-btn');
        const ctx = document.getElementById('myChart').getContext('2d');

        let myChart;
        let choicesInstance;
        let allDataCache = {};
        let currentTimeRange = 'all'; // [NUEVO] Estado para el zoom
        
        const COLOR_PALETTE = ['#e6194B', '#3cb44b', '#ffe119', '#4363d8', '#f58231', '#911eb4'];
        
        // --- [MODIFICADO] 1. Calcular Stats al Cargar CSV ---
        function calculateStats(records) {
            const stats = {
                min_temp: Infinity, max_temp: -Infinity,
                min_humidity: Infinity, max_humidity: -Infinity,
                min_wind: Infinity, max_wind: -Infinity,
            };
            
            records.forEach(row => {
                // Convertimos la fecha a objeto Date UNA SOLA VEZ
                row.fecha_hora = new Date(row.fecha_hora); 
                
                // Actualizamos stats
                stats.min_temp = Math.min(stats.min_temp, row.temperatura_c);
                stats.max_temp = Math.max(stats.max_temp, row.temperatura_c);
                stats.min_humidity = Math.min(stats.min_humidity, row.humedad_porc);
                stats.max_humidity = Math.max(stats.max_humidity, row.humedad_porc);
                stats.min_wind = Math.min(stats.min_wind, row.viento_kmh);
                stats.max_wind = Math.max(stats.max_wind, row.viento_kmh);
            });
            return stats;
        }

        // --- [MODIFICADO] 2. Función de Carga de CSV ---
        function loadCSV(ciudad) {
            if (allDataCache[ciudad]) {
                return Promise.resolve(allDataCache[ciudad]);
            }
            
            const nombreFichero = ciudad.replace(/ /g, '_') + '.csv';
            const csvUrl = DATA_FOLDER_URL + nombreFichero;

            return new Promise((resolve, reject) => {
                Papa.parse(csvUrl, {
                    download: true,
                    header: true,
                    dynamicTyping: true,
                    skipEmptyLines: true,
                    complete: (results) => {
                        const records = results.data;
                        if (records.length === 0) {
                            allDataCache[ciudad] = { records: [], stats: {} };
                            resolve(allDataCache[ciudad]);
                            return;
                        }
                        
                        // Calculamos stats y convertimos fechas
                        const stats = calculateStats(records);
                        
                        // Guardamos en caché el objeto completo
                        allDataCache[ciudad] = { records, stats }; 
                        console.log(`Datos y stats calculados para ${ciudad}`);
                        resolve(allDataCache[ciudad]);
                    },
                    error: (err) => {
                        console.error(`Error cargando ${csvUrl}:`, err);
                        reject(err);
                    }
                });
            });
        }

        // --- 3. Función de Carga Múltiple (Sin cambios) ---
        async function loadDataForCities(ciudades) {
            const promises = ciudades.map(ciudad => loadCSV(ciudad));
            try {
                const datasets = await Promise.all(promises);
                const cityDataMap = {};
                ciudades.forEach((ciudad, index) => {
                    cityDataMap[ciudad] = datasets[index];
                });
                return cityDataMap;
            } catch (error) {
                console.error("Fallo al cargar uno o más datasets:", error);
                kpiContainer.innerHTML = "<p>Error al cargar los datos. Revisa la consola.</p>";
                return null;
            }
        }

        // --- 4. Función para Actualizar el Dashboard (Sin cambios) ---
        async function updateDashboard() {
            const selectedCities = choicesInstance.getValue(true);
            const selectedMetric = document.querySelector('input[name="metric"]:checked').value;

            if (selectedCities.length === 0) {
                kpiContainer.innerHTML = "<p>Selecciona una o más ciudades para empezar.</p>";
                if (myChart) myChart.destroy();
                return;
            }
            
            const cityDataMap = await loadDataForCities(selectedCities);
            if (!cityDataMap) return;

            updateKPIs(cityDataMap, selectedMetric); // Pasamos la métrica
            updateChart(cityDataMap, selectedMetric);
        }

        // --- [MODIFICADO] 5. Función para Actualizar las Tarjetas de KPI ---
        function updateKPIs(cityDataMap, selectedMetric) {
            kpiContainer.innerHTML = '';
            
            Object.keys(cityDataMap).forEach((ciudad, index) => {
                const data = cityDataMap[ciudad]; // Ahora es { records: [], stats: {} }
                if (!data || data.records.length === 0) return;

                const latestData = data.records[data.records.length - 1];
                const stats = data.stats;
                const cardColor = COLOR_PALETTE[index % COLOR_PALETTE.length];

                // [NUEVO] Lógica para Min/Max dinámico
                let minHist, maxHist, unit;
                switch(selectedMetric) {
                    case 'humidity':
                        minHist = stats.min_humidity.toFixed(0);
                        maxHist = stats.max_humidity.toFixed(0);
                        unit = '%';
                        break;
                    case 'wind':
                        minHist = stats.min_wind.toFixed(1);
                        maxHist = stats.max_wind.toFixed(1);
                        unit = ' km/h';
                        break;
                    default: // 'temp'
                        minHist = stats.min_temp.toFixed(1);
                        maxHist = stats.max_temp.toFixed(1);
                        unit = '°C';
                }

                const cardHTML = `
                    <div class="kpi-card" style="border-left-color: ${cardColor};">
                        <h3>${ciudad}</h3>
                        <p class="kpi-temp">${latestData.temperatura_c.toFixed(1)} °C</p>
                        <p>Sensación: <strong>${latestData.sensacion_c.toFixed(1)} °C</strong></p>
                        <p>Humedad: <strong>${latestData.humedad_porc} %</strong></p>
                        <p>Viento: <strong>${latestData.viento_kmh} km/h</strong></p>
                        
                        <div class="kpi-hist">
                            <span>Min Hist (${unit}): <strong>${minHist}</strong></span>
                            <span>Max Hist (${unit}): <strong>${maxHist}</strong></span>
                        </div>
                    </div>
                `;
                kpiContainer.innerHTML += cardHTML;
            });
        }
        
        // --- [MODIFICADO] 6. Función para Actualizar el Gráfico Histórico (con Zoom) ---
        function updateChart(cityDataMap, metric) {
            if (myChart) {
                myChart.destroy();
            }
            
            const metricMap = {
                'temp': { key: 'temperatura_c', label: 'Temperatura (°C)' },
                'humidity': { key: 'humedad_porc', label: 'Humedad (%)' },
                'wind': { key: 'viento_kmh', label: 'Viento (km/h)' }
            };
            const currentMetric = metricMap[metric];
            
            // [NUEVO] Lógica de Filtro de Tiempo (Zoom)
            const now = new Date();
            let startDate = new Date(0); // 1 de Enero de 1970 (para "Todo")
            
            if (currentTimeRange !== 'all') {
                startDate = new Date();
                startDate.setDate(now.getDate() - parseInt(currentTimeRange));
            }

            const datasets = [];
            let allLabels = [];
            let hasData = false; // Flag para saber si hay datos después de filtrar

            Object.keys(cityDataMap).forEach((ciudad, index) => {
                const data = cityDataMap[ciudad];
                if (!data || data.records.length === 0) return;

                // [NUEVO] Filtramos los datos por el rango de tiempo
                const filteredData = data.records.filter(row => row.fecha_hora >= startDate);
                
                if (filteredData.length > 0) {
                    hasData = true;
                }

                const chartData = filteredData.map(fila => fila[currentMetric.key]);
                
                // Unificamos el eje X (solo si es el primer dataset con datos)
                if (index === 0 || allLabels.length === 0) {
                    allLabels = filteredData.map(fila => {
                        return fila.fecha_hora.toLocaleString('es-ES', { 
                            day: 'numeric', month: 'short', hour: '2-digit', minute: '2-digit' 
                        });
                    });
                }
                
                datasets.push({
                    label: `${ciudad} - ${currentMetric.label}`,
                    data: chartData,
                    borderColor: COLOR_PALETTE[index % COLOR_PALETTE.length],
                    backgroundColor: 'transparent',
                    tension: 0.1
                });
            });
            
            // Si no hay datos después de filtrar (ej. pulsas "1S" y no hay datos),
            // mostramos un gráfico vacío en lugar de un error.
            if (!hasData) {
                allLabels = [];
            }

            myChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: allLabels,
                    datasets: datasets
                },
                options: { /* ... (opciones idénticas a antes) ... */ }
            });
        }

        // --- [MODIFICADO] 7. Función de Inicialización ---
        async function init() {
            // Inicializamos Choices.js
            choicesInstance = new Choices(citySelectorElement, {
                removeItemButton: true,
                maxItemCount: 5,
                placeholder: true,
                placeholderValue: 'Escribe para buscar...',
                searchResultLimit: 50,
            });

            // Cargamos lista de ciudades
            try {
                const response = await fetch(CITIES_LIST_URL);
                const text = await response.text();
                const ciudades = text.split('\n')
                                     .map(city => city.trim())
                                     .filter(city => city.length > 0)
                                     .map(city => ({ value: city, label: city }));
                
                choicesInstance.setChoices(ciudades, 'value', 'label', false);
                choicesInstance.setChoiceByValue(['Madrid', 'León']);
                updateDashboard();

            } catch (error) {
                console.error("Error al cargar la lista de ciudades:", error);
                alert("No se pudo cargar la lista de ciudades.");
            }
            
            // --- Añadimos los Listeners ---
            
            // 1. Para el selector de ciudades
            citySelectorElement.addEventListener('change', updateDashboard);
            
            // 2. Para los radios de métrica
            metricRadios.forEach(radio => radio.addEventListener('change', updateDashboard));

            // 3. [NUEVO] Para los botones de rango de tiempo (Zoom)
            timeRangeButtons.forEach(button => {
                button.addEventListener('click', () => {
                    // Actualizamos el estado global
                    currentTimeRange = button.dataset.range;
                    
                    // Actualizamos la clase 'active' para el CSS
                    timeRangeButtons.forEach(btn => btn.classList.remove('active'));
                    button.classList.add('active');
                    
                    // Volvemos a dibujar todo
                    updateDashboard();
                });
            });
        }

        // --- INICIO DE LA APLICACIÓN ---
        init();
    </script>
</body>
</html>