<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard Climático Global (v2.0)</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/choices.js@9.0.1/public/assets/styles/choices.min.css"/>
    <script src="https://cdn.jsdelivr.net/npm/choices.js@9.0.1/public/assets/scripts/choices.min.js"></script>

    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #f0f2f5;
            color: #333;
            margin: 0;
            padding: 20px;
        }
        h1 {
            color: #2c3e50;
            text-align: center;
        }
        
        /* Contenedor de Controles */
        #controls-container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 30px; /* Espacio entre los controles */
            flex-wrap: wrap; /* Para móviles */
            padding: 20px;
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
            margin-bottom: 20px;
        }
        
        /* Estilo para el selector de ciudades (Choices.js) */
        .choices__inner {
            background-color: #fff;
        }
        #city-select-container {
            width: 500px;
        }

        /* Estilo para el selector de métrica (Radio buttons) */
        #metric-select fieldset {
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
            display: flex;
            gap: 15px;
        }
        #metric-select legend {
            font-weight: bold;
            padding: 0 5px;
        }

        /* [NUEVO] Contenedor para los KPIs (Tarjetas) */
        #kpi-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        .kpi-card {
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
            padding: 15px;
            border-left: 5px solid #1abc9c;
        }
        .kpi-card h3 {
            margin: 0 0 10px 0;
            color: #2c3e50;
        }
        .kpi-card p {
            margin: 5px 0;
            font-size: 1.1em;
        }
        .kpi-card .kpi-temp {
            font-weight: bold;
            font-size: 1.5em;
            color: #e74c3c;
        }
        
        /* Contenedor del Gráfico */
        #chart-container {
            width: 100%;
            padding: 20px;
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
            box-sizing: border-box; /* Para que el padding no afecte al ancho */
        }
    </style>
</head>
<body>

    <h1>Dashboard Climático Global (v2.0)</h1>

    <div id="controls-container">
        <div id="city-select-container">
            <label for="city-select" style="font-weight: bold; margin-bottom: 5px; display: block;">Selecciona hasta 5 ciudades:</label>
            <select id="city-select" multiple></select>
        </div>
        
        <div id="metric-select">
            <fieldset>
                <legend>Métrica a comparar</legend>
                <label><input type="radio" name="metric" value="temp" checked> Temperatura</label>
                <label><input type="radio" name="metric" value="humidity"> Humedad</label>
                <label><input type="radio" name="metric" value="wind"> Viento</label>
            </fieldset>
        </div>
    </div>

    <h2>Datos más recientes</h2>
    <div id="kpi-container">
        </div>

    <h2>Evolución Histórica</h2>
    <div id="chart-container">
        <canvas id="myChart"></canvas>
    </div>

    <script>
        // --- Configuración Global ---
        const CITIES_LIST_URL = 'ciudades.txt';
        const DATA_FOLDER_URL = 'datos/';
        
        // Elementos del DOM
        const citySelectorElement = document.getElementById('city-select');
        const kpiContainer = document.getElementById('kpi-container');
        const metricRadios = document.querySelectorAll('input[name="metric"]');
        const ctx = document.getElementById('myChart').getContext('2d');

        // Variables de estado
        let myChart; // El objeto Chart.js
        let choicesInstance; // El objeto Choices.js
        let allDataCache = {}; // Caché para no recargar CSVs (¡muy importante!)
        
        // Paleta de colores para el gráfico
        const COLOR_PALETTE = ['#e6194B', '#3cb44b', '#ffe119', '#4363d8', '#f58231', '#911eb4'];
        
        // --- 1. Función de Carga de CSV (Devuelve una Promesa) ---
        function loadCSV(ciudad) {
            // Si ya lo tenemos en caché, lo devolvemos al instante
            if (allDataCache[ciudad]) {
                return Promise.resolve(allDataCache[ciudad]);
            }
            
            const nombreFichero = ciudad.replace(/ /g, '_') + '.csv';
            const csvUrl = DATA_FOLDER_URL + nombreFichero;

            // Devolvemos una Promesa que se resolverá cuando PapaParse termine
            return new Promise((resolve, reject) => {
                Papa.parse(csvUrl, {
                    download: true,
                    header: true,
                    dynamicTyping: true,
                    skipEmptyLines: true,
                    complete: (results) => {
                        console.log(`Datos cargados para ${ciudad}`);
                        allDataCache[ciudad] = results.data; // Guardamos en caché
                        resolve(results.data);
                    },
                    error: (err) => {
                        console.error(`Error cargando ${csvUrl}:`, err);
                        reject(err);
                    }
                });
            });
        }

        // --- 2. Función de Carga de Múltiples Ciudades ---
        async function loadDataForCities(ciudades) {
            // Creamos un array de promesas (una por cada ciudad)
            const promises = ciudades.map(ciudad => loadCSV(ciudad));
            
            try {
                // Esperamos a que TODAS las promesas se completen
                const datasets = await Promise.all(promises);
                console.log("Todos los datasets se han cargado.");
                
                // 'datasets' es un array de arrays, ej: [ [datosMadrid], [datosLeon], ... ]
                // Mapeamos los datos con sus nombres para que sea más fácil
                const cityDataMap = {};
                ciudades.forEach((ciudad, index) => {
                    cityDataMap[ciudad] = datasets[index];
                });

                return cityDataMap;

            } catch (error) {
                console.error("Fallo al cargar uno o más datasets:", error);
                kpiContainer.innerHTML = "<p>Error al cargar los datos. Revisa la consola.</p>";
                return null;
            }
        }

        // --- 3. Función para Actualizar el Dashboard ---
        async function updateDashboard() {
            // Obtenemos las selecciones actuales
            const selectedCities = choicesInstance.getValue(true); // Pide los valores como string
            const selectedMetric = document.querySelector('input[name="metric"]:checked').value;

            if (selectedCities.length === 0) {
                kpiContainer.innerHTML = "<p>Selecciona una o más ciudades para empezar.</p>";
                if (myChart) myChart.destroy();
                return;
            }
            
            // Cargamos todos los datos necesarios
            const cityDataMap = await loadDataForCities(selectedCities);
            if (!cityDataMap) return;

            // Actualizamos ambas secciones
            updateKPIs(cityDataMap);
            updateChart(cityDataMap, selectedMetric);
        }

        // --- 4. Función para Actualizar las Tarjetas de KPI ---
        function updateKPIs(cityDataMap) {
            kpiContainer.innerHTML = ''; // Limpiamos el contenedor
            
            Object.keys(cityDataMap).forEach((ciudad, index) => {
                const data = cityDataMap[ciudad];
                if (data.length === 0) return;

                // Tomamos el último registro (el más reciente)
                const latestData = data[data.length - 1];
                
                // Asignamos un color de la paleta
                const cardColor = COLOR_PALETTE[index % COLOR_PALETTE.length];
                
                // Creamos el HTML de la tarjeta
                const cardHTML = `
                    <div class="kpi-card" style="border-left-color: ${cardColor};">
                        <h3>${ciudad}</h3>
                        <p class="kpi-temp">${latestData.temperatura_c.toFixed(1)} °C</p>
                        <p>Sensación: <strong>${latestData.sensacion_c.toFixed(1)} °C</strong></p>
                        <p>Humedad: <strong>${latestData.humedad_porc} %</strong></p>
                        <p>Viento: <strong>${latestData.viento_kmh} km/h</strong></p>
                    </div>
                `;
                kpiContainer.innerHTML += cardHTML;
            });
        }
        
        // --- 5. Función para Actualizar el Gráfico Histórico ---
        function updateChart(cityDataMap, metric) {
            if (myChart) {
                myChart.destroy(); // Destruimos el gráfico anterior
            }
            
            // Mapeo de métricas a claves del CSV
            const metricMap = {
                'temp': { key: 'temperatura_c', label: 'Temperatura (°C)' },
                'humidity': { key: 'humedad_porc', label: 'Humedad (%)' },
                'wind': { key: 'viento_kmh', label: 'Viento (km/h)' }
            };
            const currentMetric = metricMap[metric];
            
            // Creamos los 'datasets' para Chart.js
            const datasets = [];
            let allLabels = []; // Usaremos un eje X común

            Object.keys(cityDataMap).forEach((ciudad, index) => {
                const data = cityDataMap[ciudad];
                if (data.length === 0) return;

                // Extraemos los datos para la métrica seleccionada
                const chartData = data.map(fila => fila[currentMetric.key]);
                
                // Extraemos las etiquetas de fecha (solo del primer dataset para unificar el eje X)
                if (index === 0) {
                    allLabels = data.map(fila => {
                        const fecha = new Date(fila.fecha_hora);
                        return fecha.toLocaleString('es-ES', { day: 'numeric', month: 'short', hour: '2-digit' });
                    });
                }
                
                // Añadimos el dataset de esta ciudad
                datasets.push({
                    label: `${ciudad} - ${currentMetric.label}`,
                    data: chartData,
                    borderColor: COLOR_PALETTE[index % COLOR_PALETTE.length],
                    backgroundColor: 'transparent',
                    tension: 0.1
                });
            });

            // Creamos el nuevo gráfico
            myChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: allLabels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: `Evolución Histórica de ${currentMetric.label}`,
                            font: { size: 18 }
                        },
                        legend: {
                            position: 'top',
                        }
                    },
                    scales: {
                        y: {
                            title: {
                                display: true,
                                text: currentMetric.label
                            }
                        }
                    },
                    interaction: {
                        mode: 'index',
                        intersect: false
                    }
                }
            });
        }

        // --- 6. Función de Inicialización ---
        async function init() {
            // Inicializamos el selector de ciudades con Choices.js
            choicesInstance = new Choices(citySelectorElement, {
                removeItemButton: true,
                maxItemCount: 5, // Límite de 5 ciudades
                placeholder: true,
                placeholderValue: 'Escribe para buscar...',
                searchResultLimit: 50,
            });

            // Cargamos la lista de ciudades.txt
            try {
                const response = await fetch(CITIES_LIST_URL);
                const text = await response.text();
                const ciudades = text.split('\n')
                                     .map(city => city.trim())
                                     .filter(city => city.length > 0)
                                     .map(city => ({ value: city, label: city })); // Formato para Choices.js
                
                choicesInstance.setChoices(ciudades, 'value', 'label', false);
                
                // Cargamos Madrid y León por defecto
                choicesInstance.setChoiceByValue(['Madrid', 'León']);
                updateDashboard();

            } catch (error) {
                console.error("Error al cargar la lista de ciudades:", error);
                alert("No se pudo cargar la lista de ciudades.");
            }
            
            // Añadimos los "listeners" para que el dashboard reaccione
            citySelectorElement.addEventListener('change', updateDashboard);
            metricRadios.forEach(radio => radio.addEventListener('change', updateDashboard));
        }

        // --- INICIO DE LA APLICACIÓN ---
        init();

    </script>
</body>
</html>